// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package asisgnment01_uml;

/************************************************************/
/**
 * 
 */
public class Board {
	/**
	 * 
	 */
	private Tile[] tiles;
	/**
	 * 
	 */
	private Node[] nodes;
	/**
	 * 
	 */
	private Edge[] edges;
	/**
	 * 
	 */
	private BuildRoadAction layout;
	/**
	 * 
	 */
	public Tile tile;
	/**
	 * 
	 */
	public Node node;
	/**
	 * 
	 */
	public Edge edge;
	/**
	 * 
	 */
	public BoardLayout boardlayout;

	/**
	 * 
	 * @param layout 
	 */
	public Board(BoardLayout layout) {
		// I’m using this as the real constructor so the boardlayout is set when Board is created.
		this.boardlayout = layout;

		// I’m initializing arrays to empty so the code compiles and won’t null-crash.
		this.tiles = new Tile[0];
		this.nodes = new Node[0];
		this.edges = new Edge[0];
	}

	/**
	 * 
	 * @param id 
	 * @return 
	 */
	public Tile getTile(int id) {
		// I’m returning the tile by index as a safe placeholder.
		if (tiles == null) return null;
		if (id < 0 || id >= tiles.length) return null;
		return tiles[id];
	}

	/**
	 * 
	 * @return 
	 * @param id 
	 */
	public Node getNode(int id) {
		// I’m returning the node by index as a safe placeholder.
		if (nodes == null) return null;
		if (id < 0 || id >= nodes.length) return null;
		return nodes[id];
	}

	/**
	 * 
	 * @param a 
	 * @param b 
	 * @return 
	 */
	public Edge getEdge(Node a, Node b) {
		// I’m returning null until I implement endpoint matching for edges.
		if (edges == null) return null;
		if (a == null || b == null) return null;

		// Later I’ll search edges[] for the one connecting a and b.
		return null;
	}

	/**
	 * 
	 * @param t 
	 * @return 
	 */
	public Node[] getNodesOfTile(Tile t) {
		// I’m returning empty until Tile->Node mapping is implemented.
		return new Node[0];
	}

	/**
	 * 
	 * @param n 
	 * @return 
	 */
	public Tile[] getTilesOfNode(Node n) {
		// I’m returning empty until Node->Tile mapping is implemented.
		return new Tile[0];
	}

	/**
	 * 
	 * @param n 
	 * @return 
	 */
	public Node[] getAdjacentNodes(Node n) {
		// I’m returning empty until adjacency logic is implemented.
		return new Node[0];
	}
}
