// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package asisgnment01_uml;

/************************************************************/
/**
 * 
 */
public class Game {
	/**
	 * 
	 */
	private Board Board;
	/**
	 * 
	 */
	private int currentRound;
	/**
	 * 
	 */
	private int currentPlayerIndex;
	/**
	 * 
	 */
	private int maxRounds;
	/**
	 * 
	 */
	private int targetVictoryPoints;
	/**
	 * 
	 */
	private Dice dice;
	/**
	 * 
	 */
	private RuleEngine rules;
	/**
	 * 
	 */
	private ActionGenerator actionSelector;
	/**
	 * 
	 */
	private ActionLogger logger;
	/**
	 * 
	 */
	public Player winner;
	/**
	 * 
	 */
	public Board board;
	/**
	 * 
	 */
	public Player[] player;
	/**
	 * 
	 */
	public GameState gamestate;
	/**
	 * 
	 */
	public Dice dice_public;
	/**
	 * 
	 */
	public ResourceProductionEngine resourceproductionengine;
	/**
	 * 
	 */
	public ActionGenerator actiongenerator;
	/**
	 * 
	 */
	public RuleEngine ruleengine;
	/**
	 * 
	 */
	public SetupManager setupmanager;
	/**
	 * 
	 */
	public ActionLogger actionlogger;
	/**
	 * 
	 */
	public ResourceBank resourcebank;
	/**
	 * 
	 */
	private Player[] players;

	/**
	 * 
	 */
	public void setup() {
		// I’m initializing references so the game can run without null crashes.
		// Later I’ll load config, setup the board, and create players properly.

		if (this.players == null) this.players = (this.player != null) ? this.player : new Player[0];
		if (this.player == null) this.player = this.players;

		if (this.gamestate == null) this.gamestate = new GameState();

		// I’m syncing duplicated fields created by the generator.
		if (this.board == null) this.board = this.Board;
		if (this.Board == null) this.Board = this.board;

		if (this.dice == null) this.dice = this.dice_public;
		if (this.dice_public == null) this.dice_public = this.dice;
		if (this.dice == null) this.dice = new Dice();
		if (this.dice_public == null) this.dice_public = this.dice;

		if (this.ruleengine == null) this.ruleengine = this.rules;
		if (this.rules == null) this.rules = this.ruleengine;

		if (this.actiongenerator == null) this.actiongenerator = this.actionSelector;
		if (this.actionSelector == null) this.actionSelector = this.actiongenerator;

		if (this.actionlogger == null) this.actionlogger = this.logger;
		if (this.logger == null) this.logger = this.actionlogger;
		if (this.logger == null) this.logger = new ActionLogger();
		if (this.actionlogger == null) this.actionlogger = this.logger;

		this.currentRound = 1;         // I’m starting rounds at 1 for nicer logging.
		this.currentPlayerIndex = 0;

		// If maxRounds/targetVictoryPoints aren’t configured yet, I’m setting safe defaults.
		if (this.maxRounds <= 0) this.maxRounds = 1;
		if (this.targetVictoryPoints <= 0) this.targetVictoryPoints = 10;
	}

	/**
	 * 
	 */
	public void run() {
		// I’m calling setup first so the game starts in a valid state.
		setup();

		// I’m running turns until the game terminates.
		while (!checkTermination()) {
			if (players == null || players.length == 0) {
				// I can’t run without players.
				break;
			}

			Player p = players[currentPlayerIndex];
			playTurn(p);

			// Advance to next player / next round.
			currentPlayerIndex++;
			if (currentPlayerIndex >= players.length) {
				currentPlayerIndex = 0;

				// End of round logging (recommended logger version takes players).
				if (logger != null) {
					logger.logEndOfRound(currentRound, players);
				}

				currentRound++;
			}
		}
	}

	/**
	 * 
	 * @return 
	 */
	public Player getWinner() {
		// I’m returning the winner if it has been set.
		return this.winner;
	}

	/**
	 * 
	 * @param P 
	 */
	private void playTurn(Player P) {
		// I’m keeping turn logic minimal for now:
		// - roll dice (later use ResourceProductionEngine)
		// - generate executable actions
		// - select one action and execute it
		// - log the action

		if (P == null) return;

		int roll = dice.roll();
		// Later: resourceproductionengine.produce(gamestate, roll);

		boolean must = mustBuild(P);

		ActionGenerator gen = (this.actiongenerator != null) ? this.actiongenerator : this.actionSelector;
		if (gen == null) return;

		Action[] options = gen.getExecutableActions(gamestate, P, must);
		if (options == null || options.length == 0) {
			// I’m logging a “Pass” action if no actions exist.
			if (logger != null) logger.logAction(currentRound, currentPlayerIndex, "Pass");
			return;
		}

		// For now, I’m just choosing the first available action.
		// Later I’ll use an AgentStrategy to choose.
		Action chosen = options[0];

		if (chosen != null && chosen.isExecutable(gamestate, P)) {
			chosen.execute(gamestate, P);
			if (logger != null) logger.logAction(currentRound, currentPlayerIndex, chosen.describe());
		} else {
			if (logger != null) logger.logAction(currentRound, currentPlayerIndex, "Pass");
		}

		// Later: after executing, I’ll update winner if someone reached targetVictoryPoints.
	}

	/**
	 * 
	 * @return 
	 */
	private boolean checkTermination() {
		// I’m terminating if there is a winner or if we exceeded maxRounds.
		if (winner != null) return true;
		if (currentRound > maxRounds) return true;
		return false;
	}

	/**
	 * 
	 * @param P 
	 * @return 
	 */
	private boolean mustBuild(Player P) {
		// I’m returning false until I implement “must build” logic (e.g., initial placement).
		return false;
	}
}